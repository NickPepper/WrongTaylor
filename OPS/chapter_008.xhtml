<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
	<title>ПРОГРАММИРОВАНИЕ - ВВЕДЕНИЕ В ПРОФЕССИЮ I: АЗЫ ПРОГРАММИРОВАНИЯ</title>
	<meta charset="utf-8" />
	<link rel="stylesheet" href="css/stylesheet.css" type="text/css" />
</head>
<body>
<section class="body-rw Chapter-rw" epub:type="bodymatter chapter">
<header>
	<h3>1.4. Как правильно использовать компьютер</h3>
</header>

<header>
	<h4>1.4.1. Операционные системы и виды пользовательского интерфейса</h4>
</header>

<div class="block-rw extract-rw">
	<p>Установивший Windows сначала месяц радуется, потом всю жизнь мучается.<br/>Установивший Unix сначала месяц мучается, потом всю жизнь радуется.</p>
	<p class="source-rw">Из подслушанного у студентов</p>
</div>

<p>В предыдущем параграфе мы упоминали особую программу, которая называется <i>операционной системой</i>. В её основные задачи входит, во-первых, управление запуском и завершением других программ; во-вторых, операционная система берёт на себя управление периферийными устройствами во всём их многообразии, а всем остальным программам предоставляет упрощённые возможности для доступа к периферии: так, пользовательская программа может обратиться к операционной системе с просьбой открыть какой-нибудь файл на чтение (указав при этом только имя файла), прочитать из него информацию, разместить эту информацию в указанной области оперативной памяти, после чего закрыть файл, то есть прекратить работу с ним. Программу при этом совершенно &#171;не волнует&#187;, на диске какого типа располагается файл: на жестком диске, встроенном в компьютер (которых, кстати, тоже очень много и очень разных), на оптическом CD или DVD, на старотипной дискете, на flash-брелке или вообще на диске другого компьютера, который подключён в качестве сетевого ресурса. Все заботы о том, какие конкретно технические операции следует выполнить, чтобы найти файл с нужным именем и извлечь из него информацию, операционная система берёт на себя.</p>

<p>Первые операционные системы появились ещё в 1960-х годах, и за прошедшие с тех пор полвека, разумеется, их было создано очень много; но, как ни странно, к нынешнему времени количество принципиально разных операционных систем изрядно сократилось. Всем известно слово &#171;Windows&#187;; так называет свои системы компания Microsoft. При этом фактически все существующие ныне операционные системы, не имеющие отношения к Microsoft (и, соответственно, слова &#171;Windows&#187; в названии), оказываются представителями семейства систем под общим названием Unix. Именно таковы свободно распространяемые системы Linux во всём многообразии его <i><strong>дистрибуций</strong></i>, таких как Debian, Ubuntu, Fedora, Slackware, Gentoo и многие другие, и FreeBSD, вариаций которой гораздо меньше, но тоже есть. Кроме того, к семейству Unix относятся Android, который основан на ядре Linux, а также Mac OS X и iOS, которые, как и FreeBSD, ведут своё начало от версии Unix, созданной в университете Беркли (как мы помним, аббревиатура BSD означает <i>Berkeley Software Distribution</i>).</p>

<p>Роль, задачи и принципы работы операционных систем&#160;&#8212; это тема для долгого обсуждения, которому мы посвятим в этой книге отдельную часть&#160;&#8212; пятую; пока отметим, что в задачи операционных систем, вопреки распространённому заблуждению, никоим образом не входит организация взаимодействия с пользователем, т. е. человеком, который работает с компьютером. Дело тут в том, что операционные системы сами по себе достаточно сложны&#160;&#8212; по большому счёту, это едва ли не самые сложные программы из существующих в мире; поэтому их создатели обычно стараются всё, что может быть сделано вне операционной системы, именно вне её и делать. При этом средства общения компьютера с пользователем&#160;&#8212; так называемый <i><strong>пользовательский интерфейс</strong></i>&#160;&#8212; не обязан быть частью операционной системы, его может поддерживать обычная программа. Именно так делается во всех вариантах Unix; за рисование окошек, переключение между ними и всё такое прочее отвечают разнообразные <i>надстройки</i>, написанные в виде обычных программ, запускающихся под управлением операционной системы, но при этом не являющихся её частью. В операционных системах Microsoft, напротив, поддержка графического интерфейса включена в ядро системы, что приводит, в частности, к невозможности для пользователя самостоятельно выбрать интерфейс; работать приходится с тем единственным интерфейсом, который предоставлен системой.</p>

<p>Коль скоро речь пошла о графическом пользовательском интерфейсе, следует отметить, что в некоторых случаях он в системе вообще не нужен. Например, серверные компьютеры, обслуживающие запросы пользователей по компьютерной сети, чаще всего размещают в специальных стойках для аппаратуры, причём в зависимости от конкретной задачи в одну стойку может войти от десятка до двух-трёх сотен компьютеров, каждый со своим процессором, памятью и периферийными устройствами. Процессоры и блоки питания компьютеров нуждаются в охлаждении&#160;&#8212; как правило, воздушном, то есть с помощью обычных вентиляторов; эти вентиляторы при таком количестве компьютеров, размещённых в одном месте, могут производить изрядный шум. Поэтому для размещения серверов обычно предусматривают специальное помещение, в котором человеку находиться некомфортно из-за шума, из-за пониженной температуры воздуха, которая специально поддерживается кондиционерами для обеспечения более надёжной работы компьютеров, из-за сквозняков, создаваемых вентиляторами. Более того, физическое отсутствие людей в серверной улучшает условия для работы компьютеров&#160;&#8212; в помещение никто не приносит пыль и грязь, не выделяет в воздух лишнюю влагу, не спотыкается о провода. Поэтому люди в такое помещение заходят, только когда требуется что-то сделать с аппаратурой&#160;&#8212; отремонтировать её, установить новую, заменить старую; бывает, что ни один живой человек не появляется в серверной в течение нескольких месяцев. Все настройки и управление работой серверных машин производятся удалённо, из других помещений, где находятся рабочие места программистов и системных администраторов. Многие серверные компьютеры вообще не имеют в своём составе видеокарты, то есть монитор к ним подключить нельзя; до начала массового распространения USB к таким компьютерам невозможно было подключить также и клавиатуру. Зачем, спрашивается, на таких машинах поддерживать графический интерфейс, которого никто и никогда не увидит?</p>

<p>Большинство конечных пользователей <a epub:type="noteref" href="#n1_1_16">16</a> компьютеров в наши дни не понимает, как вообще можно использовать компьютер, если на нём нет графического интерфейса, но это, по большому счёту, лишь следствие проводимой некоторыми корпорациями пропаганды. Вплоть до середины 1990-х годов графические пользовательские интерфейсы не имели такого всеобъемлющего распространения, как сейчас, что совершенно не мешало людям пользоваться компьютерами, да и сейчас многие пользователи предпочитают копировать файлы и просматривать содержимое дисков с помощью двухпанельных файловых мониторов, таких как Far Manager или Total Commander, идеологическим предшественником которых был Norton Commander, работавший в текстовом режиме. Любопытно, что даже традиционный оконный интерфейс, в котором подразумевается возможность менять размеры окон, перемещать их по экрану, частично накладывать друг на друга и т. п., первоначально был реализован без всякой графики, на экране алфавитно-цифрового монитора.</p>

<p>Впрочем, и Norton Commander со всеми его поздними клонами, и оконные интерфейсы, использовавшие текстовый режим (а во времена MS-DOS они были весьма популярны), хотя и не используют графику как таковую, всё же основаны на том же базовом принципе, что и привычные ныне &#171;иконочно-менюшечные&#187; интерфейсы: пространство экрана они используют для размещения так называемых <i>элементов интерфейса</i>, или &#171;виджетов&#187;, которые обычно включают меню, кнопки, флажки и переключатели (англ. <i>checkboxes</i> и <i>radiobuttons</i>), поля для ввода текстовой информации, а также статические поясняющие надписи; использование графического режима несколько расширяет репертуар виджетов, включая в него окна с пиктограммами (&#171;иконками&#187;), всевозможные ползунки, индикаторы и другие элементы, на которые хватило фантазии у разработчика. Между тем, понаблюдав за работой профессионалов&#160;&#8212; программистов и системных администраторов, в особенности тех из них, кто использует системы семейства Unix, можно заметить ещё один подход к взаимодействию человека с компьютером: <i><strong>командную строку</strong></i>. В этом режиме пользователь вводит с клавиатуры <i><strong>команды</strong></i>, предписывающие выполнение тех или иных действий, а компьютер эти команды исполняет и выводит на экран результаты; когда-то давно именно это называлось <i><strong>диалоговым режимом</strong></i> работы с компьютером, в отличие от <i><strong>пакетного режима</strong></i>, когда операторы заранее формировали пакеты заданий, полученных от программистов, а компьютер эти задания обрабатывал по мере готовности.</p>

<br/>
<small>
	<p>Первоначально диалоговый режим работы с компьютерами строился с помощью так называемых <i>телетайпов</i> <a epub:type="noteref" href="#n1_1_17">17</a>, которые представляли собой электромеханическую пишущую машинку, подключаемую к линии связи. Исходное предназначение телетайпов состояло в передаче текстовых сообщений на расстоянии; ещё совсем недавно для срочных сообщений использовали <i>телеграммы</i>, которые почтальон доставлял на дом адресату, причём полученная телеграмма представляла собой полоски печатного текста, выданного телетайпом, вырезанные ножницами и наклеенные на плотное основание. Телеграммы были практически полностью вытеснены из обихода развитием цифровых сетей связи&#160;&#8212; мобильной телефонии и Интернета.</p>

	<p>Подключить телетайп к компьютеру догадались ещё в эпоху первого поколения ЭВМ; свою роль сыграло то обстоятельство, что телетайпы к тому времени серийно производились для нужд телеграфии и были доступны на рынке, то есть их не надо было разрабатывать, а компьютерным инженерам того времени хватало других забот. Работая с компьютером в диалоговом режиме с помощью телетайпа, оператор набирал команду на клавиатуре, а ответ компьютера печатался на бумажной ленте. Интересно, что такой режим работы &#171;продержался&#187; на удивление долго: он был полностью вытеснен из практики лишь к концу 1970-х годов.</p>

	<p>Использование телетайпа в качестве устройства доступа к компьютеру имело очевидный недостаток: расходовалось очень много бумаги. Первоначально именно это стало причиной массового перехода от традиционных телетайпов к алфавитно-цифровым <i><strong>терминалам</strong></i>, которые были оснащены клавиатурой и устройством отображения (экраном) на основе электронно-лучевой трубки (кинескопа); всё, что оператор набирал на клавиатуре, передавалось в линию связи, а информация, полученная оттуда, отображалась на экране. Например, если два терминала соединить друг с другом, операторы смогут между собой &#171;поговорить&#187;.</p>

	<p>Экран вместо бумажной ленты существенно расширил имеющиеся возможности; в частности, для терминалов практически сразу были введены управляющие цепочки символов, известные как <i>escape-последовательности</i> (от названия спецсимвола Escape, имеющего код 27), при получении которых терминал перемещал курсор в указанную позицию на экране, менял цвет выводимого текста и т. п.</p>

	<p>Сейчас алфавитно-цифровые терминалы больше не выпускаются; при необходимости с этой ролью может справиться любой ноутбук, оснащённый последовательным портом или переходником USB-serial, если на нём запустить соответствующее программное обеспечение; кстати, первоначальная настройка упоминавшихся выше серверных машин, не имеющих видеокарты, производится именно так: системный администратор подключает свой рабочий компьютер через COM-порт к настраиваемой серверной машине и запускает у себя эмулятор терминала. Это позволяет произвести загрузку операционной системы с внешнего носителя, установить её на серверную машину, настроить связь с локальной сетью и средства удалённого доступа; дальнейшая настройка, а также управление в ходе эксплуатации обычно производятся удалённо по сети, поскольку это удобнее&#160;&#8212; настраиваемый компьютер уже не нужно связывать шнуром напрямую с машиной администратора.</p>
</small>
<br/>

<br/>
<p class="centered">
	<img src="images/teletype.jpg" /><br/>
	<small>Рис. 1.4. Телетайп ASR-33 с перфоратором и устройством чтения перфолент <a epub:type="noteref" href="#n1_1_18">18</a></small>
</p>
<br/><br/>

<p>Иногда можно услышать, что системы семейства Unix якобы <i>неудобны для пользователя, потому что там приходится работать с командной строкой</i>. Это, разумеется, миф, истоками которого служат перепутанные причины и следствия. Опровергнуть этот миф проще простого: вряд ли кто-нибудь, кто хотя бы раз видел ноутбук от Apple, заявит, что в MacOS X отсутствует графический интерфейс пользователя; наоборот, он там едва ли не самый &#171;развесистый&#187;. Большинство &#171;обычных&#187; пользователей этим вполне удовлетворяется, но когда очередной макбук оказывается в руках профессионала, среди всего великолепия графического интерфейса <i>внезапно</i> обнаруживается эмулятор терминала с приглашением командной строки.</p>

<p>Практически то же самое происходит на современных дистрибуциях свободно распространяемых Unix-систем, ориентированных на конечного пользователя. Бросается в глаза разнообразие графических оболочек, используемых там. Как уже говорилось, графический интерфейс пользователя здесь не является частью операционной системы; больше того, в отличие от коммерческих систем, включающих ту же MacOS X, внешний вид пользовательского интерфейса в традиционных системах не зашит намертво в графическую надстройку, а реализуется отдельной программой, которая называется <i><strong>оконным менеджером</strong></i>. Пользователь может выбрать тот внешний вид и функциональность оконной системы, которые ему удобнее, а при определённой сноровке&#160;&#8212; менять вид и поведение оконной системы, например, в зависимости от настроения, причём прямо во время работы, даже не закрывая окна запущенных приложений.</p>

<p>Разумеется, для Linux и FreeBSD давно существуют, кроме прочего, и &#171;иконочные&#187; файловые менеджеры, причём их написано довольно много&#160;&#8212; Nautilus, Dolphin, Konqueror, PCManFM, Thunar, Nemo, SpaceFM, ROX Desktop, Xfe и другие; ещё шире представлены <i>двухпанельные файловые менеджеры</i>, продолжающие традиции знаменитого Norton Commander: это текстовый Midnight Commander, а также графические gentoo (его не следует путать с одноимённым дистрибутивом Linux), Krusader, emelFM2, Sunflower, GNOME Commander, Double Commander, muCommander и т. п. Тем не менее многие профессионалы предпочитают работать с файлами&#160;&#8212; копировать их, переименовывать, сортировать по отдельным каталогам <a epub:type="noteref" href="#n1_1_19">19</a>, перебрасывать с диска на диск, удалять&#160;&#8212; с помощью команд командной строки. Это объясняется одним очень простым фактом: так действительно удобнее и быстрее.</p>

<br/>
<p class="centered">
	<img src="images/terminal.jpg" /><br/>
	<small>Рис. 1.5. Терминал vt100 <a epub:type="noteref" href="#n1_1_20">20</a></small>
</p>
<br/><br/>

<p>Интересно, что средства командной строки присутствуют и в системах семейства Windows; получить окно терминала с соответствующим приглашением там можно, если нажать пресловутую кнопку &#171;Пуск&#187; (Start), выбрать в меню пункт &#171;Выполнить&#187; (Run) и в качестве имени команды ввести три буквы &#171;cmd&#187;; но стандартный интерпретатор командной строки под Windows очень примитивен, использовать его неудобно, а большинство пользователей даже не подозревают о его существовании. Профессионалам он тоже не подходит, так что в мире Windows даже они вынуждены обходиться графическими интерфейсами, задействуя командную строку только в редких случаях, как правило, связанных с обслуживанием системы. Программисты, привыкшие к Unix-системам и по тем или иным причинам вынужденные работать с Windows, часто устанавливают там перенесённые из-под Unix интерпретаторы командной строки; например, такой интерпретатор входит в пакет MinGW.</p>

<p>Конечно, командная строка требует некоторого <i>запоминания</i>, но команд, которые необходимо запомнить, не так много; между тем графические интерфейсы, несмотря на все заявления об их &#171;интуитивной понятности&#187;, <i>тоже вынуждают много чего запомнить</i>: чего стоит одно только использование клавиш Ctrl и Shift в сочетании с &#171;мышкой&#187; при выделении элементов (это ещё довольно просто, поскольку результат сразу же виден) и при копировании файлов, их перемещении и создании &#171;ярлыков&#187;. Обучение работе с графическими интерфейсами &#171;с нуля&#187;, то есть когда обучаемый вообще не имеет никакого опыта работы с компьютером, оказывается на поверку тяжелее, чем обучение работе со средствами командной строки; широкая публика потихоньку перестаёт замечать это просто потому, что сейчас к графическим интерфейсам люди начинают привыкать с дошкольного возраста в силу их широкого распространения&#160;&#8212; которое, в свою очередь, является скорее результатом усилий PR-подразделений определённых коммерческих корпораций, нежели следствием весьма сомнительного &#171;удобства&#187; графических интерфейсов. Зачастую пользователь привыкает не к графическому интерфейсу в принципе, а к конкретной версии такового и оказывается совершенно беспомощен, например, при переходе на другую версию операционной системы.</p>

<p>Конечно, прежде чем средства работы с командной строкой стали действительно удобными, им пришлось пройти долгий путь совершенствования. Современные интерпретаторы командной строки &#171;помнят&#187; несколько сотен последних введённых пользователем команд и позволяют быстро и без усилий найти нужную команду среди запомненных; кроме того, они позволяют редактировать вводимую команду с помощью клавиш &#171;стрелок&#187;, &#171;угадывать&#187; имя файла по первым введённым буквам, некоторые варианты интерфейса командной строки выдают пользователю контекстные подсказки относительно того, что ещё можно написать в этой части вводимой команды, и т.п. Работа с такой командной строкой при условии хорошего уровня владения ею может происходить <i>в разы и даже в десятки раз быстрее</i>, чем выполнение тех же действий с помощью сколь угодно &#171;навороченного&#187; графического интерфейса. Представьте себе, к примеру, что вы вернулись из поездки в Париж и хотите скопировать на свой компьютер фотографии с карточки фотоаппарата. Команды</p>

<br/>
<p class="codecite">
cd Photoalbum/2015<br/>
mkdir Paris<br/>
cd Paris<br/>
mount /mnt/flash<br/>
cp /mnt/flash/dcim/* .<br/>
umount /mnt/flash<br/>
</p>
<br/>

<p>с учётом автодополнения имён файлов и использования истории команд можно, не особенно торопясь, набрать за шесть-семь секунд, ведь бо&#769;льшую часть текста вообще не придётся набирать: скорее всего, у вас в домашнем каталоге только имя подкаталога Photoalbum начинается с Ph, так что достаточно будет набрать только эти две буквы, нажать клавишу Tab, и командный интерпретатор допишет имя Photoalbum, услужливо поставив после него косую черту; то же самое можно сделать при наборе команды &#171;mount /mnt/flash&#187; (каталог mnt&#160;&#8212; скорее всего, единственный в корневом каталоге начинается с m, а его подкаталог flash&#160;&#8212; скорее всего, единственный, который начинается с f); вместо &#171;cp /mnt/flash/dcim/* .&#187; опытный пользователь наберёт &#171;cp !:1/dcim/* .&#187;, а интерпретатор вместо &#171;!:1&#187; подставит первый аргумент предыдущей команды, то есть &#171;/mnt/flash&#187;; команду &#171;umount /mnt/flash&#187; набирать не нужно, достаточно будет набрать &#171;u!m&#187; (вместо !m будет подставлен текст последней команды, начинавшейся с m), или просто нажать два раза стрелку вверх и в появившейся на экране команде mount /mnt/flash добавить в начало букву u.</p>

<p>Если те же действия выполнять через интерфейс с пиктограммами, то вам понадобится сначала щелчками мышки добраться до содержимого карточки, затем, используя мышку в сочетании с клавишей Shift, пометить весь список файлов, правой кнопкой мышки вызвать контекстное меню, выбрать в нём действие &#171;копировать&#187;, затем найти (всё теми же щелчками мышки) каталог Photoalbum/2014, снова вызвать контекстное меню, создать подкаталог Paris, двойным щелчком зайти в него и, наконец, вызвав контекстное меню в третий раз, выбрать в нём пункт &#171;вставить&#187;. Даже если всё делать быстро, у вас на эту процедуру уйдёт никак не меньше двадцати-тридцати секунд, а то и больше. Но это, как ни странно, не главное. Если вы, к примеру, очень часто копируете фотографии к себе на диск, то с использованием командной строки эту процедуру можно автоматизировать, написав так называемый <i><strong>скрипт</strong></i>&#160;&#8212; обычный текстовый файл, состоящий из команд. Для нашего примера скрипт может выглядеть так:</p>

<br/>
<p class="codecite">
#!/bin/bash<br/>
cd Photoalbum/2015<br/>
mkdir $1<br/>
cd $1<br/>
mount /mnt/flash<br/>
cp /mnt/flash/dcim/* .<br/>
umount /mnt/flash<br/>
</p>
<br/>

<p>но опытный пользователь, скорее всего, напишет скрипт более гибко:</p>

<br/>
<p class="codecite">
#!/bin/bash<br/>
DIR=Photoalbum/2015<br/>
[ "x&#36;1" = x ] &#38;&#38; { echo "No dir name"; exit 1 }<br/>
mkdir &#36;DIR/&#36;1<br/>
mount /mnt/flash<br/>
cp /mnt/flash/dcim/* $DIR/&#36;1<br/>
umount /mnt/flash<br/>
</p>
<br/>

<p>Если теперь назвать любой из этих двух скриптов, например, getphotos, то в следующий раз, когда потребуется скопировать новые фотографии (например, по возвращении из Милана), достаточно будет дать команду</p>

<br/>
<p class="codecite">
./getphotos Milan<br/>
</p>
<br/>

<p>С графическими интерфейсами такой фокус не проходит: в отличие от команд, движения и щелчки мышки не поддаются формальному описанию, во всяком случае, достаточно простому для практического использования.</p>

<p>Отметим, что запуск графических/оконных программ тоже гораздо правильнее осуществлять из командной строки, нежели использовать для этого всевозможные меню. Например, если вы знаете адрес сайта, на который хотите попасть, то для запуска браузера проще всего дать команду:</p>

<br/>
<p class="codecite">
firefox http://www.stolyarov.info &#38;<br/>
</p>
<br/>

<p>Само имя запускаемой программы (в данном случае firefox) не настолько длинное, чтобы с его набором могли быть какие-то проблемы, особенно с учётом автодополнения&#160;&#8212; например, автору на его компьютере оказалось достаточно набрать только буквы fir и нажать Tab; ну а адрес сайта вам всё равно пришлось бы набрать на клавиатуре, только, возможно, не в командной строке, а в соответствущем окошке браузера.</p>

<p>Примечательна выразительная мощь современных командных интерпретаторов: например, в них можно использовать текст, выведенный одной командой, в качестве части другой команды, не говоря уже о том, что результат работы одной программы можно направить на вход другой программы, и таким образом построить целую цепочку преобразований информации, называемую <i>конвейером</i>. Каждая программа, появившаяся в вашей системе, в том числе и написанная лично вами, может быть использована в бесконечном количестве сочетаний с другими программами и встроенными средствами самого интерпретатора командной строки; при этом вы можете воспользоваться программами других авторов для таких целей, о которых их авторы даже не подозревали. Вообще, <strong>если возможности графического пользовательского интерфейса ограничены фантазией его разработчика, то возможности правильно организованной командной строки ограничены только возможностями компьютера</strong>.</p>

<p>Эти возможности, во всяком случае, заведомо стоят того, чтобы их изучить. Конечно, преодолеть влияние пропаганды &#171;софтверных&#187; монстров и убедить всех пользователей компьютеров перейти на командную строку&#160;&#8212; задача в современных условиях нереальная; но, коль скоро вы читаете эту книгу, по-видимому, вы не совсем обычный пользователь. Так вот, <strong>для профессионала в сфере информационных технологий свободное владение средствами командной строки практически обязательно</strong>; отсутствие этих навыков резко снижает вашу ценность как специалиста. Наконец, очень важно и то, что интерфейс командной строки оказывается чрезвычайно полезен в ходе начального обучения программированию, если угодно, в качестве учебного пособия. Причины этого подробно изложены в &#171;методическом предисловии&#187;, но оно может оказаться непонятным для неспециалиста; в таком случае автору остаётся только просить читателя на некоторое время принять важность командной строки на веру; это ненадолго, вскоре вам всё станет понятно.</p>

<p>Вся наша книга написана в предположении, что на вашем компьютере установлена та или иная система семейства Unix и что вы используете для работы с компьютером интерфейс командной строки; тому, как это делается, посвящён остаток этой главы. Хотя мы уже говорили об этом в предисловии, но сочтём уместным повторить: если вы хотите чему-то научиться с помощью этой книги, интерфейс командной строки должен стать для вас основным способом повседневной работы с компьютером, причём это должно произойти как можно раньше.</p>

<aside epub:type="footnote" id="n1_1_16">
	<p>Под <i><strong>конечным пользователем</strong></i> обычно подразумевают человека, который с помощью компьютеров решает какие-то свои задачи, никак не связанные с дальнейшим использованием компьютеров; например, секретарь или дизайнер, используя компьютер, являются при этом конечными пользователями, а программист&#160;&#8212; нет, поскольку задачи, которые он решает, нацелены на организацию работы других пользователей (или даже его самого) с компьютером. Вполне возможно, что конечными пользователями окажутся те, кто будет использовать программу, которую сейчас пишет программист.</p>
</aside>
<aside epub:type="footnote" id="n1_1_17">
	<p>Интересно отметить, что в русском языке слово &#171;телетайп&#187; прочно закрепилось в качестве нарицательного обозначения соответствующих устройств, тогда как в англоязычных источниках чаще используется термин &#171;телепринтер&#187; (teleprinter); дело в том, что слово <i>teletype</i> являлось зарегистрированной торговой маркой одного из производителей такого оборудования.</p>
</aside>
<aside epub:type="footnote" id="n1_1_18">
	<p>Фото с сайта Википедии, см. http://en.wikipedia.org/wiki/File:ASR-33_at_CHM.agr.jpg</p>
</aside>
<aside epub:type="footnote" id="n1_1_19">
	<p>В наше время в ходу термин &#171;папка&#187;; этот термин, на самом деле означающий элемент графического интерфейса&#160;&#8212; то самое &#171;окошко с иконками&#187;&#160;&#8212; неприемлем для именования объекта файловой системы, содержащего имена файлов. В частности, папки совершенно не обязательно как-либо представлены на диске, а иконки в них не обязаны соответствовать файлам; в то же время с файлами и каталогами можно работать без &#171;папок&#187;&#160;&#8212; ни двухпанельные файловые менеджеры, ни командная строка никаких &#171;папок&#187; не подразумевают. В этой книге мы используем корректную терминологию; термины &#171;каталог&#187; и &#171;директория&#187; мы считаем равноправными, а слово &#171;папка&#187;, кроме этой сноски, вам больше нигде в тексте не встретится.</p>
</aside>
<aside epub:type="footnote" id="n1_1_20">
	<p>Там же, см. http://en.wikipedia.org/wiki/File:DEC_VT100_terminal.jpg</p>
</aside>
</section>
</body>
</html>