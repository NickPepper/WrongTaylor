<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
	<title>ПРОГРАММИРОВАНИЕ - ВВЕДЕНИЕ В ПРОФЕССИЮ I: АЗЫ ПРОГРАММИРОВАНИЯ</title>
	<meta charset="utf-8" />
	<link rel="stylesheet" href="css/stylesheet.css" type="text/css" />
</head>
<body>
<section class="body-rw Chapter-rw" epub:type="bodymatter chapter">
<header>
	<h4>1.4.13. Командные файлы в Bourne Shell</h4>
</header>

<p>Интерпретатор Bourne Shell может не только работать в режиме диалога с пользователем, но и выполнять программы, которые называются командными файлами (<i>скриптами</i>). Файл с программой, предназначенной для исполнения интерпретатором Bourne Shell, должен начинаться со строки</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;&#35;!/bin/sh<br/>
</p>
<br/>

<p>Переменные в языке Bourne Shell имеют имена, состоящие из латинских букв, цифр, знака подчёркивания и начинающиеся всегда с буквы. Значением переменной может быть любая строка символов. Чтобы присвоить переменной значение, нужно написать оператор присваивания, например:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;I=10<br/>
&#160;&#160;&#160;&#160;MYFILE=/tmp/the_file_name<br/>
&#160;&#160;&#160;&#160;MYSTRING="Here are several words"<br/>
</p>
<br/>

<p>Обратите внимание, что в имени переменной, а также вокруг знака равенства (символа присваивания) не должно быть пробелов, в противном случае команда будет расценена не как присваивание, а как обычная команда, в которой знак присваивания&#160;&#8212; один из параметров. Для обращения к переменной используется знак &#36;, например:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;echo &#36;I &#36;MYFILE &#36;MYSTRING<br/>
</p>
<br/>

<p>В результате выполнения этой команды будет напечатано:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;10 /tmp/the_file_name Here are several words<br/>
</p>
<br/>

<p>При необходимости скомпоновать слитный текст из значений переменных можно имена переменных заключать в фигурные скобки; например, команда &#171;echo &#36;{I}abc&#187; напечатает &#171;10abc&#187;.</p>

<p>Для выполнения арифметических действий используется конструкция &#36;(( )). Например, команда &#171;I=&#36;(( $I + 7 ))&#187; увеличит значение переменной I на семь.</p>

<p>С помощью встроенной в интерпретатор Bourne Shell команды test можно осуществлять проверку выполнения различных условий. Если заданное условие выполнено, команда завершится с нулевым (успешным) кодом возврата, в противном случае&#160;&#8212; с единичным (неуспешным). Синонимом команды test является символ открывающей квадратной скобки, причём сама команда в этом случае воспринимает символ закрывающей квадратной скобки в качестве своего параметра (как знак окончания выражения), что позволяет наглядно записывать проверяемое выражение, заключая его в квадратные скобки. Приведём несколько примеров.</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;[ -f "file.txt" ]<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#35; существует ли файл с именем file.txt<br/>
&#160;&#160;&#160;&#160;[ "&#36;I" -lt 25 ]<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#35; значение переменной I меньше 25<br/>
&#160;&#160;&#160;&#160;[ "&#36;A" = "abc" ]<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#35; значение переменной A является строкой abc<br/>
&#160;&#160;&#160;&#160;[ "&#36;A" != "abc" ]<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#35; значение переменной A не является строкой abc<br/>
</p>
<br/>

<p>Это можно, например, использовать в операторе ветвления:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;if [ -f "file.txt" ]; then<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cat "file.txt"<br/>
&#160;&#160;&#160;&#160;else<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;echo "Файл file.txt не найден"<br/>
&#160;&#160;&#160;&#160;fi<br/>
</p>
<br/>

<p>Заметим, что то же самое можно было написать и иначе, без использования квадратных скобок, но это менее наглядно:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;if test "file.txt" ; then<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cat "file.txt"<br/>
&#160;&#160;&#160;&#160;else<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;echo "Файл file.txt не найден"<br/>
&#160;&#160;&#160;&#160;fi<br/>
</p>
<br/>

<p>В качестве команды, проверяющей условие, может фигурировать не только test, но и любая другая команда. Например:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;if gcc -Wall -g myprog.c -o myprog; then<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;echo "Compiled successfully"<br/>
&#160;&#160;&#160;&#160;else<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;echo "Failed to compile"<br/>
&#160;&#160;&#160;&#160;fi<br/>
</p>
<br/>

<p>Кроме оператора ветвления, язык Bourne Shell поддерживает и более сложные конструкции, в том числе циклы. Например, следующий фрагмент напечатает все числа от 1 до 100:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;I=0<br/>
&#160;&#160;&#160;&#160;while [ &#36;I -le 101 ]; do<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;echo &#36;I<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;I=&#36;(( I + 1 ))<br/>
&#160;&#160;&#160;&#160;done<br/>
</p>
<br/>

<p>Использовать информацию об успешности выполнения команды можно также с помощью так называемых логических связок &#38;&#38; и &#124;&#124;, означающих, соответственно, логические операции &#171;и&#187; и &#171;или&#187;. При этом логическому значению &#171;истина&#187; соответствует успешное завершение команды, а значению &#171;ложь&#187;&#160;&#8212; неуспешное. Командная строка</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;cmd1 &#38;&#38; cmd2<br/>
</p>
<br/>

<p>заставит интерпретатор выполнить сначала команду cmd1; а команда cmd2 будет выполнена только в случае, если cmd1 завершилась <strong>успешно</strong>. Наоборот, командная строка</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;cmd1 &#124;&#124; cmd2<br/>
</p>
<br/>

<p>подразумевает запуск cmd2 в случае <strong>неуспешного</strong> завершения cmd1.</p>

<br/>
<small>
	<p>Приоритет логических связок между собой&#160;&#8212; традиционный (то есть &#171;и&#187; приоритетнее, чем &#171;или&#187;). В то же время приоритет операций &#171;конвейер&#187; и перенаправлений ввода-вывода выше, чем приоритет логических связок; так, команда</p>

	<br/>
	<p class="codecite">
	&#160;&#160;&#160;&#160;cmd1 &#38;&#38; cmd2 &#124; cmd3<br/>
	</p>
	<br/>

	<p>представляет собой связку между командой cmd1 и конвейером cmd2 | cmd3 как целым. Значение &#171;истинности&#187; конвейера определяется успешностью или неуспешностью выполнения последней из составляющих его команд. Очерёдность применения операций, как обычно, можно изменить использованием круглых скобок, например:</p>

	<br/>
	<p class="codecite">
	&#160;&#160;&#160;&#160;(cmd1 &#38;&#38; cmd2) &#124; cmd3<br/>
	</p>
	<br/>

	<p>В этом примере стандартный вывод команд cmd1 и cmd2 (если, конечно, она вообще будет выполняться) будет направлен на стандартный ввод cmd3.</p>
</small>
<br/>

<p>Для более подробной информации о программировании на языке Bourne Shell следует обратиться к специальной литературе [1].</p>

</section>
</body>
</html>