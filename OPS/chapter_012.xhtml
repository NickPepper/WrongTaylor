<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
	<title>ПРОГРАММИРОВАНИЕ - ВВЕДЕНИЕ В ПРОФЕССИЮ I: АЗЫ ПРОГРАММИРОВАНИЯ</title>
	<meta charset="utf-8" />
	<link rel="stylesheet" href="css/stylesheet.css" type="text/css" />
</head>
<body>
<section class="body-rw Chapter-rw" epub:type="bodymatter chapter">
<header>
	<h4>1.4.5. Шаблоны имён файлов</h4>
</header>

<p>Во многих случаях бывает удобно произвести ту или иную операцию сразу над несколькими файлами. Для этого командный интерпретатор поддерживает <i><strong>подстановку имён файлов по заданному шаблону</strong></i>. В качестве шаблона интерпретатор рассматривает любое слово, не заключённое в кавычки или апострофы, содержащее хотя бы один символ &#171;*&#187; или &#171;?&#187;, квадратные или фигурные скобки. Знак вопроса в шаблоне считается соответствующим одному произвольному символу, а знак звёздочки&#160;&#8212; произвольной цепочке символов (в том числе, возможно, пустой); смысл скобок мы поясним чуть позже. Остальные символы в шаблоне обозначают сами себя. Встретив в командной строке такой шаблон, интерпретатор заменяет его списком из всех имён файлов, соответствующих шаблону, то есть в общем случае слово-шаблон может быть заменено на последовательность слов, имеющую произвольную длину: одно слово, десять, сто, тысяча, сколько угодно&#160;&#8212; в зависимости от того, сколько файлов соответствуют шаблону. Например, вместо шаблона, состоящего из одной звёздочки (или из произвольного количества звёздочек), интерпретатор подставит список всех файлов из текущей директории; вместо шаблона &#171;???*&#187; будут подставлены все имена файлов, состоящие не менее чем из трёх символов, а вместо &#171;???&#187;&#160;&#8212; имена файлов, состоящие ровно из трёх символов. Шаблон &#171;*.txt&#187; заменится на список всех имён файлов, имеющих суффикс <a epub:type="noteref" href="#n1_1_24">24</a> .txt, а шаблону img_????.jpg будут соответствовать имена вроде img_2578.jpg, img_cool.jpg и прочее в таком духе.</p>

<p>Применять шаблоны можно в любых командах, предполагающих списки имён файлов в качестве аргументов. Например, команда rm *~ удалит в текущей директории все файлы, в имени которых последним символом стоит тильда, команда &#171;ls /etc/*conf.&#187; покажет список файлов с суффиксом .conf, находящихся в директории /etc, команда &#171;cp files/* /mnt/flash&#187; скопирует в директорию /mnt/flash все файлы из поддиректории files, находящейся в текущей директории, и так далее. В принципе команда, которую мы заставляем работать с шаблонами, не обязана предполагать именно файлы; так, команда &#171;echo *&#187; напечатает список файлов в текущей директории; между тем, команда echo сама по себе не имеет никакого отношения к файлам и не работает с файлами: она <i>печатает свои аргументы командной строки</i>.</p>

<p>Квадратные скобки в шаблоне позволяют обозначить <i>любой символ из заданного множества</i>; например, шаблон &#171;img_27[234][0123456789].jpg&#187; соответствует именам img_2720.jpg, img_2721.jpg, ..., img_2734.jpg, ..., img_2749.jpg и более никаким. Конечно, в реальной жизни можно воспользоваться тем обстоятельством, что, скорее всего, в директории нет ни одного файла, у которого в имени вместо четвёртой цифры стояло бы что-то другое, и воспользоваться более коротким шаблоном &#171;img_27[234]?.jpg&#187;. Символ восклицательного знака позволяет, напротив, обозначить любой символ <i>кроме перечисленных</i>; например, &#171;[!_]*.c&#187; соответствует любым именам файлов, имеющим суффикс &#171;.c&#187;, за исключением начинающихся с символа подчёркивания.</p>

<p>Фигурные скобки в шаблонах обозначают любую <i>цепочку</i> символов из явно перечисленных, сами цепочки при этом разделяются запятой. Например, шаблон &#171;*.{jpg,png,gif}&#187; соответствует всем файлам из текущей директории, имеющим суффиксы .jpg, .png или .gif.</p>

<p><strong>Если шаблону не соответствует ни одно имя файла, интерпретатор оставляет шаблон без изменений</strong>, то есть передаёт слово вызываемой команде, как если бы это слово вообще не было шаблоном. Использовать эту возможность следует с осторожностью; большинство командных интерпретаторов, отличных от bash, такой особенности не имеют.</p>


<aside epub:type="footnote" id="n1_1_24">
	<p>Читатель, привыкший к традиционной терминологии мира Windows, может удивиться использованию термина &#171;суффикс&#187; вместо &#171;расширения&#187;. Дело здесь в том, что в MS-DOS и ранних версиях Windows &#171;расширение&#187; файла было намертво связано с его типом и рассматривалось обособленно от имени, тогда как в системах семейства Unix окончание имени файла никогда не играло такой роли и всегда было просто частью имени.</p>
</aside>
</section>
</body>
</html>