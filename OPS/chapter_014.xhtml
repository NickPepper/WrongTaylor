<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
	<title>ПРОГРАММИРОВАНИЕ - ВВЕДЕНИЕ В ПРОФЕССИЮ I: АЗЫ ПРОГРАММИРОВАНИЯ</title>
	<meta charset="utf-8" />
	<link rel="stylesheet" href="css/stylesheet.css" type="text/css" />
</head>
<body>
<section class="body-rw Chapter-rw" epub:type="bodymatter chapter">
<header>
	<h4>1.4.7. Управление выполнением задач</h4>
</header>

<p>Далеко не все команды исполняются мгновенно, как это делали в наших примерах pwd, cd и ls; часто требуется сообщить запущенной программе, что пора заканчивать работу, а если она не понимает по-хорошему&#160;&#8212; прекратить её выполнение принудительно.</p>

<p>Первое, что нужно помнить при работе в командной строке Unix&#160;&#8212; это что многие программы подразумевают чтение данных с клавиатуры (говоря строже, &#171;из потока стандартного ввода&#187;) до тех пор, пока там не возникнет <i><strong>ситуация конца файла</strong></i>. С этим моментом у начинающих часто возникают определённые сложности: как может кончиться файл, более-менее понятно, но как то же самое может произойти с <i>клавиатурой</i>?! Но на самом деле ничего сложного тут нет. В ОС Unix используется обобщённый термин &#171;поток данных&#187;, который может означать как чтение из файла, так и ввод данных с клавиатуры, или ещё откуда-нибудь; подробный разговор об этом у нас впереди. Одним из фундаментальных свойств потока данных является его способность <i>заканчиваться</i>.</p>

<p>Естественно, клавиатура сама по себе &#171;кончиться&#187; не может, но пользователь, вводящий данные, имеет полное право решить, что он уже ввёл всё, что хотел. Чтобы сообщить об этом активной программе (то есть той программе, которая в данный момент читает информацию, вводимую с клавиатуры), нужно нажать комбинацию клавиш Ctrl-D; при этом операционная система (если быть точным, драйвер терминала) устроит в соответствующем потоке ввода ситуацию &#171;конец файла&#187;, и хотя наша клавиатура вроде бы никуда не делась, активная программа будет точно знать, что её входной поток информации иссяк. Между прочим, командный интерпретатор, который ведёт с нами диалог, тоже корректно обрабатывает ситуацию конца файла, так что если вы хотите завершить сеанс работы в одном из окон с командной строкой, наиболее корректный способ сделать это&#160;&#8212; нажать Ctrl-D; отметим заодно, что закрывать окно терминала средствами оконного менеджера (всякими дабл-кликами или через менюшки)&#160;&#8212; напротив, способ самый <i>некорректный</i>, поступать так с терминалами ни в коем случае не следует.</p>

<p>Умение имитировать на клавиатуре ситуацию &#171;конец файла&#187; ещё не раз потребуется нам в дальнейшем, так что <strong>запомните: &#171;конец файла&#187; на клавиатуре имитируется нажатием Ctrl-D</strong>.</p>

<br/>

<p>Конечно, активная программа совершенно не обязана завершаться при обнаружении конца файла; больше того, она может вообще не читать ничего из своего стандартного потока ввода, так что о наступлении в нём ситуации конца файла просто не узнает. В конце концов, программа может просто &#171;зависнуть&#187; из-за какой-нибудь ошибки. Во всех подобных случаях нужно знать, как прекратить выполнение программы, не дожидаясь, когда она закончится сама.</p>

<p>Простейший и наиболее общепринятый способ принудительного завершения активной программы&#160;&#8212; это нажатие комбинации Ctrl-C; в большинстве случаев это поможет. К сожалению, бывает и так, что от Ctrl-C не наблюдается никакого эффекта; в этом случае можно попробовать нажать Ctrl-\, в некоторых случаях активную программу это всё-таки остановит, но после этого (в зависимости от настроек системы) в текущем каталоге может появиться файл с именем core (в системе FreeBSD&#160;&#8212; файл с суффиксом .core), который стоит удалить сразу же, как только вы его увидели&#160;&#8212; он занимает довольно много места и при этом для вас пока совершенно бесполезен.</p>

<p>Чего точно не следует делать&#160;&#8212; это использовать комбинацию Ctrl-Z до тех пор, пока вы не поймёте, что она <strong>в действительности</strong> делает в ОС Unix. Этот вопрос мы подробно обсудим чуть позже.</p>

<br/>
<small>
	<p>Прежде чем переходить к использованию &#171;тяжёлой артиллерии&#187;, следует ещё вспомнить, что терминалы обычно позволяют временно останавливать вывод (чтобы, например, успеть прочитать нужный фрагмент текста и не дать ему &#171;прокрутиться&#187; за пределы экрана). Такая &#171;пауза&#187; включается комбинацией Ctrl-S, а выключается&#160;&#8212; нажатием Ctrl-Q. Начинающие операторы Unix, привыкшие к комбинациях клавиш в графических интерфейсах, часто нажимают Ctrl-S случайно (пытаясь, например, сохранить файл в редакторе текстов и забыв, что здесь не Windows). Если вам кажется, что ваш терминал безнадёжно завис, на всякий случай попробуйте нажать Ctrl-Q: это поможет, если причиной &#171;зависания&#187; стала случайно нажатая &#171;пауза&#187;, а в остальных случаях ничего плохого всё равно не случится.</p>
</small>
<br/>

<p>Начинающие пользователи Unix часто делают ещё одну характерную ошибку&#160;&#8212; не зная, как справиться с программой, запущенной в окне терминала, они попросту закрывают само окно, например, дважды щёлкнув мышкой &#171;где следует&#187;. Такая стратегия сродни засовыванию головы в песок: зависшей программы больше не видно, но это не значит, что она исчезла. Напротив, если не помогли штатные методы, то уж закрытие терминального окна не поможет тем более: запущенная задача продолжает работать, при этом она может впустую расходовать процессорное время, память, а в некоторых случаях и ещё что-нибудь натворить.</p>

<p>Если ни Ctrl-C, ни Ctrl-\, ни Ctrl-Q не помогли, то для принудительного завершения задачи придётся разобраться (хотя бы кратко) с понятием <i><strong>процесса</strong></i> и тем, как с процессами обращаться. В самом первом приближении &#171;процесс&#187;&#160;&#8212; это программа, которая запущена и в настоящий момент выполняется в системе; иначе говоря, когда вы запускаете любую программу, в системе появляется процесс, а когда программа заканчивает выполнение, соответствующий процесс исчезает (завершается). На самом деле всё несколько сложнее, например, запущенная вами программа может по своему усмотрению породить ещё несколько процессов и т. д.; всё это будет обсуждаться во втором томе нашей книги, в части, посвящённой операционным системам. Пока нас волнует вопрос сугубо прагматический: если мы запустили программу, в результате чего в системе возник процесс, то как этот процесс найти и уничтожить?</p>

<p>Отметим сразу же, что все процессы имеют в системе свои уникальные номера, благодаря которым их можно различать между собой. Список процессов, выполняющихся в настоящий момент, можно получить командой ps:</p>

<br/>
<p class="codecite">
&#36; ps<br/>
PID TTY&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;TIME&#160;&#160;&#160;&#160;&#160;CMD<br/>
2199 pts/5&#160;&#160;&#160;&#160;00:00:00 bash<br/>
2241 pts/5&#160;&#160;&#160;&#160;00:00:00 ps<br/>
</p>
<br/>

<p>Как видно, команда по умолчанию выдаёт только список процессов, запущенных в данном конкретном сеансе работы. К сожалению, флаги команды ps очень сильно отличаются в зависимости от версии (в частности, для FreeBSD и Linux). За подробной информацией следует обращаться к документации по данной конкретной ОС; здесь мы ограничимся замечанием, что команда &#171;ps ax&#187; выдаст список всех существующих процессов, а команда &#171;ps axu&#187; дополнительно покажет информацию о владельцах процессов <a epub:type="noteref" href="#n1_1_25">25</a>.</p>

<p>В некоторых случаях может оказаться полезной программа top, работающая интерактивно. Она выдаёт на экран список наиболее активных процессов, обновляя его один раз в секунду. Чтобы выйти из программы top, нужно ввести букву q.</p>

<p>Снять процесс можно с помощью так называемого <i><strong>сигнала</strong></i>; заметим, именно это происходит при нажатиии упоминавшихся выше комбинаций Ctrl-C и Ctrl-\, сигналы процессу при этом посылает драйвер терминала. Каждый сигнал имеет свой номер, название и некую предопределённую роль; больше про сигналы ничего толком сказать нельзя, понятие &#171;отправки процессу сигнала&#187; невозможно пояснить, не влезая в дебри, но нам это сейчас не требуется. Достаточно знать, во-первых, что процессу можно отправить сигнал с заданным номером (или именем); во-вторых, что процесс может сам решить, как реагировать на большинство сигналов, в том числе не реагировать на них вообще никак; и в-третьих, что существуют такие сигналы, над которыми процессы не властны; это позволяет убить процесс наверняка.</p>

<p>Комбинации Ctrl-C и Ctrl-\ отправляют активному процессу соответственно сигналы SIGINT и SIGQUIT (для наглядности отметим, что они имеют номера 2 и 3, но помнить это не нужно). Обычно оба этих сигнала приводят к немедленному завершению процесса; если этого не произошло&#160;&#8212; скорее всего, ваш процесс их &#171;перехватил&#187; и для его снятия придётся применить неперехватываемый сигнал SIGKILL (&#8470;9). Отправить процессу произвольный сигнал позволяет команда kill, но прежде чем её применять, нужно узнать номер процесса, который мы хотим уничтожить. Для этого обычно открывают ещё одно окно терминала и в нём дают команду ps ax; в появившемся списке будут показаны как номера процессов, так и их командные строки, что обычно позволяет узнать номер нужного нам процесса. Например, если вы написали программу prog, запустили её, а она так качественно зависла, что не помогают никакие комбинации, то в выдаче команды ps ax ближе к концу вы, скорее всего, найдёте примерно такую строку:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;2763 pts/6&#160;&#160;&#160;&#160;R+&#160;&#160;&#160;&#160;&#160;0:06 ./prog<br/>
</p>
<br/>

<p>Опознать нужную строку следует по имени программы (в данном случае ./prog), а номер процесса посмотреть в начале строки (здесь это 2763). Зная этот номер, мы можем применить команду kill, но следует помнить, что по умолчанию она отправляет указанному процессу сигнал SIGTERM, (&#8470;15), который тоже может быть перехвачен процессом. Задать другой сигнал можно либо по номеру, либо по названию (TERM, KILL, INT и т. п.). Следующие две команды эквивалентны; обе передают процессу 2763 сигнал SIGKILL:</p>

<br/>
<p class="codecite">
&#160;&#160;&#160;&#160;kill -9 2763<br/>
&#160;&#160;&#160;&#160;kill -KILL 2763<br/>
</p>
<br/>

<br/>
<small>
	<p>Очень редко процесс не исчезает даже после этого. Так может произойти только в двух случаях. Во-первых, это может быть так называемый процесс-зомби, который на самом деле уже завершился, но остаётся в системе, поскольку его непосредственный предок&#160;&#8212; тот, кто его запустил&#160;&#8212; почему-то не торопится затребовать у операционной системы информацию об обстоятельствах завершения своего потомка. Зомби убить нельзя&#160;&#8212; он уже и так мёртвый, помочь тут может разве что уничтожение его предка, тогда исчезнет и сам зомби. Впрочем, зомби не потребляет ресурсов системы, он только занимает место в таблице процессов, что неприятно, но не очень страшно.</p>
	
	<p>Вторая ситуация гораздо хуже. Процесс мог выполнить системный вызов, то есть обратиться к операционной системе за какой-то услугой, в ходе выполнения которой система перевела его в состояние &#171;непрерываемого сна&#187;, в котором он и остался. Обычно система переводит процессы в такое состояние на доли секунды; если процесс остался в таком виде надолго&#160;&#8212; в большинстве случаев это означает серьёзные проблемы с вашим компьютером, например, испорченный (физически!) диск. Здесь, к сожалению, не поможет вообще ничего; принудительно вывести процесс из такого состояния невозможно. Впрочем, если у вас начал &#171;сыпаться&#187; диск, скорее всего вам должно быть уже не до процессов.</p>

	<p>Узнать, какая из двух ситуаций имеет место, можно из выдачи всё той же команды ps ax. Процесс-зомби отмечается буквой Z в столбце STAT и словом &#171;defunct&#187; в столбце командной строки, примерно так:</p>

	<br/>
	<p class="codecite">
	&#160;&#160;&#160;&#160;3159 pts/6&#160;&#160;&#160;&#160;Z+&#160;&#160;&#160;&#160;&#160;0:00 [prog] &#60;defunct&#62;<br/>
	</p>
	<br/>

	<p>Процесс в состоянии &#171;непрерываемого сна&#187; можно отличить по букве D в поле STAT:</p>

	<br/>
	<p class="codecite">
	&#160;&#160;&#160;&#160;4711 pts/6&#160;&#160;&#160;&#160;D&#160;&#160;&#160;&#160;0:01 badblocks /dev/sdc1<br/>
	</p>
	<br/>

	<p>Если какой-нибудь процесс находится в таком состоянии хотя бы несколько секунд&#160;&#8212; это повод проверить, всё ли хорошо с вашим компьютером.</p>
</small>
<br/>


<aside epub:type="footnote" id="n1_1_25">
	<p>Это верно для ОС Linux и FreeBSD. В других ОС, например в SunOS/Solaris, ключи команды ps имеют совершенно иной смысл.</p>
</aside>
</section>
</body>
</html>